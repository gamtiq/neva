{"version":3,"sources":["../src/neva.js"],"names":["getEmitter","dataField","getHandlerIndex","emitter","type","handler","context","eventData","i","length","obj","item","api","hasEventHandler","eventName","on","typeList","eventType","push","off","splice","emit","params","eventObj","data","call","target","Object","assign"],"mappings":"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","file":"neva.common.js","sourcesContent":["/*\r\n * neva\r\n * https://github.com/gamtiq/neva\r\n *\r\n * Copyright (c) 2017 Denis Sikuler\r\n * Licensed under the MIT license.\r\n */\r\n\r\n\r\n/**\r\n * Simple library to work with custom events.\r\n * \r\n * @module neva\r\n */\r\n\r\nconst dataField = '__nevaEventMap';\r\n\r\n/**\r\n * Data about emitted event.\r\n *\r\n * @typedef {Object} EventData\r\n *\r\n * @property {string} type\r\n *      The event type (value of `type` parameter passed in {@link EventEmitterMixin.emit} method).\r\n * @property {Array} params\r\n *      List of additional parameters that are passed besides the event type in {@link EventEmitterMixin.emit} method.\r\n * @property {any} data\r\n *      Value of the first additional parameter that is passed in {@link EventEmitterMixin.emit} method (value of `params[0]`).\r\n */\r\n\r\n/**\r\n * An object that has methods to work with events.\r\n *\r\n * @typedef {Object} EventEmitter\r\n * @mixes EventEmitterMixin\r\n */\r\n\r\n/**\r\n * Return index of the specified event handler.\r\n *\r\n * @param {EventEmitter} emitter\r\n *      Event emitter that should be examined.\r\n * @param {string} type\r\n *      Type (name) of event whose handler list should be examined.\r\n * @param {Function} handler\r\n *      Event handler to search for.\r\n * @param {any} [context]\r\n *      Context object for the event handler to search alongside.\r\n * @return {number}\r\n *      Index of the specified handler or `-1` if the handler is not found.\r\n * @private\r\n */\r\nfunction getHandlerIndex(emitter, type, handler, context) {   // eslint-disable-line max-params\r\n    let eventData = emitter[dataField];\r\n    let i;\r\n    if (eventData && (eventData = eventData[type]) && (i = eventData.length)) {\r\n        const obj = context || null;\r\n        let item;\r\n        while (i--) {\r\n            item = eventData[i];\r\n            if (item.handler === handler && item.obj === obj) {\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n    \r\n    return -1;\r\n}\r\n\r\n/**\r\n * API for events handling.\r\n *\r\n * @mixin\r\n * @alias EventEmitterMixin\r\n */\r\nconst api = {\r\n    /**\r\n     * Check whether the specified event handler or any event handler is registered.\r\n     *\r\n     * @example\r\n     * const emitter = getEmitter();\r\n     * ...\r\n     * emitter\r\n     *      .on('event1', handler1)\r\n     *      .on('event2', obj.handler, obj);\r\n     * ...\r\n     * emitter.hasEventHandler('event1', handler1);   // true\r\n     * emitter.hasEventHandler('event2', obj.handler, obj);   // true\r\n     * emitter.hasEventHandler('event2', handler1);   // false\r\n     * emitter.hasEventHandler('event2', obj2.handler, obj2);   // false\r\n     *\r\n     * emitter.hasEventHandler('event1');   // true\r\n     * emitter.hasEventHandler('event2');   // true\r\n     * emitter.hasEventHandler('event3');   // false\r\n     *\r\n     * emitter.hasEventHandler();   // true\r\n     *\r\n     * @param {string} [type]\r\n     *      Type (name) of event to check for.\r\n     *      If type is not passed it means that existence of any handler for any type should be checked.\r\n     * @param {Function} [handler]\r\n     *      Handler that should be checked for the given event type.\r\n     *      If handler is not passed it means that existence of any handler for the given type should be checked.\r\n     * @param {Object} [context]\r\n     *      Context object for the event handler to check alongside.\r\n     * @return {boolean}\r\n     *      `true` if handler is registered, otherwise `false`.\r\n     */\r\n    hasEventHandler(type, handler, context) {\r\n        let eventData = this[dataField];\r\n        if (eventData) {\r\n            if (type) {\r\n                if (handler) {\r\n                    return getHandlerIndex(this, type, handler, context) > -1;\r\n                }\r\n                // eslint-disable-next-line no-cond-assign\r\n                else if (eventData = eventData[type]) {\r\n                    return eventData.length > 0;\r\n                }\r\n            }\r\n            else {\r\n                for (const eventName in eventData) {\r\n                    if (eventData[eventName].length) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    },\r\n    \r\n    /**\r\n     * Register a handler for the specified event type(s).\r\n     *\r\n     * @example\r\n     * const emitter = getEmitter();\r\n     * ...\r\n     * emitter\r\n     *      .on('occasion', (event) => {\r\n     *          ...\r\n     *      })\r\n     *      .on('close', obj.handler, obj);\r\n     * ...\r\n     * emitter.on(['event1', 'event2'], eventHandler);\r\n     *\r\n     * @param {string | string[]} type\r\n     *      Type (name) of event or list of types to listen for.\r\n     * @param {Function} handler\r\n     *      Function that should be called in response to specified event.\r\n     * @param {Object} [context]\r\n     *      An object that should be used as `this` when calling the event handler.\r\n     * @return {EventEmitter}\r\n     *      `this`.\r\n     */\r\n    on(type, handler, context) {\r\n        const eventData = this[dataField] || (this[dataField] = {});\r\n        const typeList = typeof type === 'string'\r\n                            ? [type]\r\n                            : type;\r\n        let i = typeList.length;\r\n        while (i--) {\r\n            const eventType = typeList[i];\r\n            if (! this.hasEventHandler(eventType, handler, context)) {\r\n                (eventData[eventType] || (eventData[eventType] = [])).push({\r\n                    handler,\r\n                    obj: context || null\r\n                });\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Remove the specified event handler or all handlers for given type or for all types.\r\n     *\r\n     * @example\r\n     * const emitter = getEmitter();\r\n     * ...\r\n     * emitter\r\n     *      .on('event1', handler1)\r\n     *      .on('event2', obj.handler, obj)\r\n     *      .on('event3', handler3)\r\n     *      .on('event1', handler4);\r\n     * ...\r\n     * // Remove specific handler\r\n     * emitter.off('event2', obj.handler, obj);\r\n     * // Remove all handlers for event1\r\n     * emitter.off('event1');\r\n     * // Remove all handlers for all events\r\n     * emitter.off();\r\n     *\r\n     * @param {string} [type]\r\n     *      Type (name) of event for which to remove handler(s).\r\n     *      If type is not passed then all handlers for all types will be removed.\r\n     * @param {Function} [handler]\r\n     *      Event handler that should be removed.\r\n     *      If handler is not passed then all handlers for given type will be removed.\r\n     * @param {Object} [context]\r\n     *      Context object for event handler that should be removed.\r\n     * @return {EventEmitter}\r\n     *      `this`.\r\n     */\r\n    off(type, handler, context) {\r\n        let eventData = this[dataField];\r\n        if (eventData) {\r\n            if (! type) {\r\n                this[dataField] = null;\r\n            }\r\n            // eslint-disable-next-line no-cond-assign\r\n            else if (eventData = eventData[type]) {\r\n                if (handler) {\r\n                    const obj = context || null;\r\n                    let i = eventData.length;\r\n                    let item;\r\n                    while (i--) {\r\n                        item = eventData[i];\r\n                        if (item.handler === handler && item.obj === obj) {\r\n                            eventData.splice(i, 1);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    eventData.length = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n    \r\n    /**\r\n     * Call all handlers for the specified event type.\r\n     *\r\n     * If value of `type` parameter is an object it will be passed in each handler as is.  \r\n     * If value of `type` parameter is a string an object of {@link module:neva~EventData EventData} type will be passed in each handler.\r\n     *\r\n     * @example\r\n     * const emitter = getEmitter();\r\n     * ...\r\n     * emitter.on('some-event', (event) => {\r\n     *      console.log('Emitted value: ', event.data);\r\n     * });\r\n     * ...\r\n     * emitter.emit('some-event', 'payload')\r\n     *        .emit('another-event');\r\n     * ...\r\n     * emitter.emit({type: 'eventName', value: {a: 5}});\r\n     *\r\n     * @param {Object | string} type\r\n     *      Type (name) of event or event object with `type` field for which to call handlers.\r\n     * @param {...any} [params]\r\n     *      Any values that should be available in handlers.\r\n     *      Will be used only when `type` parameter is string.\r\n     * @return {EventEmitter}\r\n     *      `this`.\r\n     */\r\n    emit(type, ...params) {\r\n        let eventData = this[dataField];\r\n        if (eventData) {\r\n            let eventObj, eventType;\r\n            if (typeof type === 'string') {\r\n                eventType = type;\r\n            }\r\n            else if (type) {\r\n                eventObj = type;\r\n                eventType = type.type;\r\n            }\r\n            // eslint-disable-next-line eqeqeq, no-eq-null\r\n            if (eventType != null && (eventData = eventData[eventType]) && eventData.length) {\r\n                if (! eventObj) {\r\n                    eventObj = {\r\n                        type,\r\n                        params,\r\n                        data: params[0]\r\n                    };\r\n                }\r\n                let i = 0;\r\n                let item;\r\n                // eslint-disable-next-line no-cond-assign\r\n                while (item = eventData[i++]) {\r\n                    item.handler.call(item.obj, eventObj);\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n};\r\n\r\n/**\r\n * Create event emitter or add methods to work with events into specified object.\r\n *\r\n * @param {Object} [target]\r\n *      Object that should be enhanced by methods to work with events.\r\n *      If `target` is not passed then new event emitter will be created and returned.\r\n * @return {EventEmitter}\r\n *      Value of `target` parameter or new object that is enhanced by methods to work with events.\r\n */\r\nexport default function getEmitter(target) {\r\n    return Object.assign(target || {}, api);\r\n}\r\n\r\nexport { getEmitter };\r\n"]}