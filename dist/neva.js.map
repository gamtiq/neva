{"version":3,"sources":["../src/neva.js"],"names":["getEmitter","dataField","getHandlerIndex","emitter","type","handler","context","eventData","i","length","obj","item","api","hasEventHandler","eventName","on","settings","typeList","eventType","push","off","splice","emit","params","eventObj","data","removeHandlerList","call","once","target","Object","assign"],"mappings":"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","file":"neva.js","sourcesContent":["/*\n * neva\n * https://github.com/gamtiq/neva\n *\n * Copyright (c) 2017-2021 Denis Sikuler\n * Licensed under the MIT license.\n */\n\n\n/**\n * Simple library to work with custom events.\n * \n * @module neva\n */\n\nconst dataField = '__nevaEventMap';\n\n/**\n * Data about emitted event.\n *\n * @typedef {Object} EventData\n *\n * @property {string} type\n *      The event type (value of `type` parameter passed in {@link EventEmitterMixin.emit} method).\n * @property {Array} params\n *      List of additional parameters that are passed besides the event type in {@link EventEmitterMixin.emit} method.\n * @property {any} data\n *      Value of the first additional parameter that is passed in {@link EventEmitterMixin.emit} method (value of `params[0]`).\n */\n\n/**\n * An object that has methods to work with events.\n *\n * @typedef {Object} EventEmitter\n * @mixes EventEmitterMixin\n */\n\n/**\n * Event handler settings.\n *\n * @typedef {Object} HandlerSettings\n *\n * @property {boolean} [once=false]\n *      Whether event handler should be called just once.\n */\n\n/**\n * Return index of the specified event handler.\n *\n * @param {module:neva~EventEmitter} emitter\n *      Event emitter that should be examined.\n * @param {string} type\n *      Type (name) of event whose handler list should be examined.\n * @param {Function} handler\n *      Event handler to search for.\n * @param {any} [context]\n *      Context object for the event handler to search alongside.\n * @return {number}\n *      Index of the specified handler or `-1` if the handler is not found.\n * @private\n */\nfunction getHandlerIndex(emitter, type, handler, context) {   // eslint-disable-line max-params\n    let eventData = emitter[dataField];\n    let i;\n    if (eventData && (eventData = eventData[type]) && (i = eventData.length)) {\n        const obj = context || null;\n        let item;\n        while (i--) {\n            item = eventData[i];\n            if (item.handler === handler && item.obj === obj) {\n                return i;\n            }\n        }\n    }\n    \n    return -1;\n}\n\n/**\n * API for events handling.\n *\n * @mixin\n * @alias EventEmitterMixin\n */\nconst api = {\n    /**\n     * Check whether the specified event handler or any event handler is registered.\n     *\n     * @example\n     * const emitter = getEmitter();\n     * ...\n     * emitter\n     *      .on('event1', handler1)\n     *      .on('event2', obj.handler, obj);\n     * ...\n     * emitter.hasEventHandler('event1', handler1);   // true\n     * emitter.hasEventHandler('event2', obj.handler, obj);   // true\n     * emitter.hasEventHandler('event2', handler1);   // false\n     * emitter.hasEventHandler('event2', obj2.handler, obj2);   // false\n     *\n     * emitter.hasEventHandler('event1');   // true\n     * emitter.hasEventHandler('event2');   // true\n     * emitter.hasEventHandler('event3');   // false\n     *\n     * emitter.hasEventHandler();   // true\n     *\n     * @param {string} [type]\n     *      Type (name) of event to check for.\n     *      If type is not passed it means that existence of any handler for any type should be checked.\n     * @param {Function} [handler]\n     *      Handler that should be checked for the given event type.\n     *      If handler is not passed it means that existence of any handler for the given type should be checked.\n     * @param {Object} [context]\n     *      Context object for the event handler to check alongside.\n     * @return {boolean}\n     *      `true` if handler is registered, otherwise `false`.\n     */\n    hasEventHandler(type, handler, context) {\n        let eventData = this[dataField];\n        if (eventData) {\n            if (type) {\n                if (handler) {\n                    return getHandlerIndex(this, type, handler, context) > -1;\n                }\n                // eslint-disable-next-line no-cond-assign\n                else if (eventData = eventData[type]) {\n                    return eventData.length > 0;\n                }\n            }\n            else {\n                for (const eventName in eventData) {\n                    if (eventData[eventName].length) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    },\n    \n    /**\n     * Register a handler for the specified event type(s).\n     *\n     * @example\n     * const emitter = getEmitter();\n     * ...\n     * emitter\n     *      .on('open', onceHandler, null, {once: true})\n     *      .on('occasion', (event) => {\n     *          ...\n     *      })\n     *      .on('close', obj.handler, obj);\n     * ...\n     * emitter.on(['event1', 'event2'], eventHandler);\n     *\n     * @param {string | string[]} type\n     *      Type (name) of event or list of types to listen for.\n     * @param {Function} handler\n     *      Function that should be called in response to specified event.\n     * @param {Object} [context]\n     *      An object that should be used as `this` when calling the event handler.\n     *      By default `null` is used.\n     * @param {module:neva~HandlerSettings} [settings]\n     *      Settings for the event handler.\n     * @return {module:neva~EventEmitter}\n     *      `this`.\n     */\n    on(type, handler, context, settings) {   // eslint-disable-line max-params\n        const eventData = this[dataField] || (this[dataField] = {});\n        const typeList = typeof type === 'string'\n            ? [type]\n            : type;\n        let i = typeList.length;\n        while (i--) {\n            const eventType = typeList[i];\n            if (! this.hasEventHandler(eventType, handler, context)) {\n                (eventData[eventType] || (eventData[eventType] = [])).push({\n                    handler,\n                    obj: context || null,\n                    settings\n                });\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * Remove the specified event handler or all handlers for given type or for all types.\n     *\n     * @example\n     * const emitter = getEmitter();\n     * ...\n     * emitter\n     *      .on('event1', handler1)\n     *      .on('event2', obj.handler, obj)\n     *      .on('event3', handler3)\n     *      .on('event1', handler4);\n     * ...\n     * // Remove specific handler\n     * emitter.off('event2', obj.handler, obj);\n     * // Remove all handlers for event1\n     * emitter.off('event1');\n     * // Remove all handlers for all events\n     * emitter.off();\n     *\n     * @param {string} [type]\n     *      Type (name) of event for which to remove handler(s).\n     *      If type is not passed then all handlers for all types will be removed.\n     * @param {Function} [handler]\n     *      Event handler that should be removed.\n     *      If handler is not passed then all handlers for given type will be removed.\n     * @param {Object} [context]\n     *      Context object for event handler that should be removed.\n     * @return {module:neva~EventEmitter}\n     *      `this`.\n     */\n    off(type, handler, context) {\n        let eventData = this[dataField];\n        if (eventData) {\n            if (! type) {\n                this[dataField] = null;\n            }\n            // eslint-disable-next-line no-cond-assign\n            else if (eventData = eventData[type]) {\n                if (handler) {\n                    const obj = context || null;\n                    let i = eventData.length;\n                    let item;\n                    while (i--) {\n                        item = eventData[i];\n                        if (item.handler === handler && item.obj === obj) {\n                            eventData.splice(i, 1);\n                        }\n                    }\n                }\n                else {\n                    eventData.length = 0;\n                }\n            }\n        }\n\n        return this;\n    },\n    \n    /**\n     * Call all handlers for the specified event type.\n     *\n     * If value of `type` parameter is an object it will be passed in each handler as is.  \n     * If value of `type` parameter is a string an object of {@link module:neva~EventData EventData} type will be passed in each handler.\n     *\n     * @example\n     * const emitter = getEmitter();\n     * ...\n     * emitter.on('some-event', (event) => {\n     *      console.log('Emitted value: ', event.data);\n     * });\n     * ...\n     * emitter.emit('some-event', 'payload')\n     *        .emit('another-event');\n     * ...\n     * emitter.emit({type: 'eventName', value: {a: 5}});\n     *\n     * @param {Object | string} type\n     *      Type (name) of event or event object with `type` field for which to call handlers.\n     * @param {...any} [params]\n     *      Any values that should be available in handlers.\n     *      Will be used only when `type` parameter is string.\n     * @return {module:neva~EventEmitter}\n     *      `this`.\n     */\n    emit(type, ...params) {\n        let eventData = this[dataField];\n        if (eventData) {\n            let eventObj, eventType;\n            if (typeof type === 'string') {\n                eventType = type;\n            }\n            else if (type) {\n                eventObj = type;\n                eventType = type.type;\n            }\n            // eslint-disable-next-line eqeqeq, no-eq-null\n            if (eventType != null && (eventData = eventData[eventType]) && eventData.length) {\n                if (! eventObj) {\n                    eventObj = {\n                        type,\n                        params,\n                        data: params[0]\n                    };\n                }\n                const removeHandlerList = [];\n                let i = 0;\n                let item;\n                let settings;\n                // eslint-disable-next-line no-cond-assign\n                while (item = eventData[i]) {\n                    item.handler.call(item.obj, eventObj);\n                    if ((settings = item.settings) && settings.once) {\n                        removeHandlerList.push(i);\n                    }\n                    i++;\n                }\n                i = removeHandlerList.length;\n                // eslint-disable-next-line no-cond-assign\n                while (i) {\n                    eventData.splice(removeHandlerList[--i], 1);\n                }\n            }\n        }\n\n        return this;\n    }\n};\n\n/**\n * Create event emitter or add methods to work with events into specified object.\n *\n * @param {Object} [target]\n *      Object that should be enhanced by methods to work with events.\n *      If `target` is not passed then new event emitter will be created and returned.\n * @return {module:neva~EventEmitter}\n *      Value of `target` parameter or new object that is enhanced by methods to work with events.\n */\nexport default function getEmitter(target) {\n    return Object.assign(target || {}, api);\n}\n\nexport { getEmitter };\n"]}