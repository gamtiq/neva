{"version":3,"sources":["../src/neva.js"],"names":["getEmitter","dataField","getHandlerIndex","emitter","type","handler","context","eventData","i","length","obj","item","api","hasEventHandler","eventName","on","typeList","eventType","push","off","splice","emit","params","eventObj","data","call","target","Object","assign"],"mappings":"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","file":"neva.js","sourcesContent":["/*\r\n * neva\r\n * https://github.com/gamtiq/neva\r\n *\r\n * Copyright (c) 2017 Denis Sikuler\r\n * Licensed under the MIT license.\r\n */\r\n\r\n\r\n/**\r\n * Simple library to work with custom events.\r\n * \r\n * @module neva\r\n */\r\n\r\nconst dataField = '__eventMap';\r\n\r\n/**\r\n * Data about emitted event.\r\n *\r\n * @typedef {Object} EventData\r\n *\r\n * @property {string} type\r\n *      The event type (value of `type` parameter passed in {@link EventEmitterMixin.emit} method).\r\n * @property {Array} params\r\n *      List of additional parameters that are passed besides the event type in {@link EventEmitterMixin.emit} method.\r\n * @property {any} data\r\n *      Value of the first additional parameter that is passed in {@link EventEmitterMixin.emit} method (value of `params[0]`).\r\n */\r\n\r\n/**\r\n * An object that has methods to work with events.\r\n *\r\n * @typedef {Object} EventEmitter\r\n * @mixes EventEmitterMixin\r\n */\r\n\r\n/**\r\n * Return index of the specified event handler.\r\n *\r\n * @param {EventEmitter} emitter\r\n *      Event emitter that should be examined.\r\n * @param {string} type\r\n *      Type (name) of event whose handler list should be examined.\r\n * @param {Function} handler\r\n *      Event handler to search for.\r\n * @param {any} [context]\r\n *      Context object for the event handler to search alongside.\r\n * @return {number}\r\n *      Index of the specified handler or `-1` if the handler is not found.\r\n * @private\r\n */\r\nfunction getHandlerIndex(emitter, type, handler, context) {   // eslint-disable-line max-params\r\n    let eventData = emitter[dataField];\r\n    let i;\r\n    if (eventData && (eventData = eventData[type]) && (i = eventData.length)) {\r\n        const obj = context || null;\r\n        let item;\r\n        while (i--) {\r\n            item = eventData[i];\r\n            if (item.handler === handler && item.obj === obj) {\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n    \r\n    return -1;\r\n}\r\n\r\n/**\r\n * API for events handling.\r\n *\r\n * @mixin EventEmitterMixin\r\n */\r\nconst api = {\r\n    /**\r\n     * Check whether the specified event handler or any event handler is registered.\r\n     *\r\n     * @example\r\n     * ```js\r\n     * const emitter = getEmitter();\r\n     * ...\r\n     * emitter\r\n     *      .on('event1', handler1)\r\n     *      .on('event2', obj.handler, obj);\r\n     * ...\r\n     * emitter.hasEventHandler('event1', handler1);   // true\r\n     * emitter.hasEventHandler('event2', obj.handler, obj);   // true\r\n     * emitter.hasEventHandler('event2', handler1);   // false\r\n     * emitter.hasEventHandler('event2', obj2.handler, obj2);   // false\r\n     *\r\n     * emitter.hasEventHandler('event1');   // true\r\n     * emitter.hasEventHandler('event2');   // true\r\n     * emitter.hasEventHandler('event3');   // false\r\n     *\r\n     * emitter.hasEventHandler();   // true\r\n     * ```\r\n     *\r\n     * @param {string} [type]\r\n     *      Type (name) of event to check for.\r\n     *      If type is not passed it means that existence of any handler for any type should be checked.\r\n     * @param {Function} [handler]\r\n     *      Handler that should be checked for the given event type.\r\n     *      If handler is not passed it means that existence of any handler for the given type should be checked.\r\n     * @param {Object} [context]\r\n     *      Context object for the event handler to check alongside.\r\n     * @return {boolean}\r\n     *      `true` if handler is registered, otherwise `false`.\r\n     */\r\n    hasEventHandler(type, handler, context) {\r\n        let eventData = this[dataField];\r\n        if (eventData) {\r\n            if (type) {\r\n                if (handler) {\r\n                    return getHandlerIndex(this, type, handler, context) > -1;\r\n                }\r\n                // eslint-disable-next-line no-cond-assign\r\n                else if (eventData = eventData[type]) {\r\n                    return eventData.length > 0;\r\n                }\r\n            }\r\n            else {\r\n                for (const eventName in eventData) {\r\n                    if (eventData[eventName].length) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    },\r\n    \r\n    /**\r\n     * Register a handler for the specified event type(s).\r\n     *\r\n     * @example\r\n     * ```js\r\n     * const emitter = getEmitter();\r\n     * ...\r\n     * emitter\r\n     *      .on('occasion', (event) => {\r\n     *          ...\r\n     *      })\r\n     *      .on('close', obj.handler, obj);\r\n     * ...\r\n     * emitter.on(['event1', 'event2'], eventHandler);\r\n     * ```\r\n     *\r\n     * @param {string | string[]} type\r\n     *      Type (name) of event or list of types to listen for.\r\n     * @param {Function} handler\r\n     *      Function that should be called in response to specified event.\r\n     * @param {Object} [context]\r\n     *      An object that should be used as `this` when calling the event handler.\r\n     * @return {EventEmitter}\r\n     *      `this`.\r\n     */\r\n    on(type, handler, context) {\r\n        const eventData = this[dataField] || (this[dataField] = {});\r\n        const typeList = typeof type === 'string'\r\n                            ? [type]\r\n                            : type;\r\n        let i = typeList.length;\r\n        while (i--) {\r\n            const eventType = typeList[i];\r\n            if (! this.hasEventHandler(eventType, handler, context)) {\r\n                (eventData[eventType] || (eventData[eventType] = [])).push({\r\n                    handler,\r\n                    obj: context || null\r\n                });\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Remove the specified event handler or all handlers for given type or for all types.\r\n     *\r\n     * @example\r\n     * ```js\r\n     * const emitter = getEmitter();\r\n     * ...\r\n     * emitter\r\n     *      .on('event1', handler1)\r\n     *      .on('event2', obj.handler, obj)\r\n     *      .on('event3', handler3)\r\n     *      .on('event1', handler4);\r\n     * ...\r\n     * // Remove specific handler\r\n     * emitter.off('event2', obj.handler, obj);\r\n     * // Remove all handlers for event1\r\n     * emitter.off('event1');\r\n     * // Remove all handlers for all events\r\n     * emitter.off();\r\n     * ```\r\n     *\r\n     * @param {string} [type]\r\n     *      Type (name) of event for which to remove handler(s).\r\n     *      If type is not passed then all handlers for all types will be removed.\r\n     * @param {Function} [handler]\r\n     *      Event handler that should be removed.\r\n     *      If handler is not passed then all handlers for given type will be removed.\r\n     * @param {Object} [context]\r\n     *      Context object for event handler that should be removed.\r\n     * @return {EventEmitter}\r\n     *      `this`.\r\n     */\r\n    off(type, handler, context) {\r\n        let eventData = this[dataField];\r\n        if (eventData) {\r\n            if (! type) {\r\n                this[dataField] = null;\r\n            }\r\n            // eslint-disable-next-line no-cond-assign\r\n            else if (eventData = eventData[type]) {\r\n                if (handler) {\r\n                    const obj = context || null;\r\n                    let i = eventData.length;\r\n                    let item;\r\n                    while (i--) {\r\n                        item = eventData[i];\r\n                        if (item.handler === handler && item.obj === obj) {\r\n                            eventData.splice(i, 1);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    eventData.length = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n    \r\n    /**\r\n     * Call all handlers for the specified event type.\r\n     *\r\n     * An object of {@link EventData} type will be passed in each handler.\r\n     *\r\n     * An object with the following fields will be passed in each handler:\r\n     * - `type: string` - the event type (value of `type` parameter).\r\n     * - `params: Array` - list of additional parameters that are passed besides the event type.\r\n     * - `data: any` - value of the second function's parameter (value of `params[0]`).\r\n     *\r\n     * @example\r\n     * ```js\r\n     * const emitter = getEmitter();\r\n     * ...\r\n     * emitter.on('some-event', (event) => {\r\n     *      console.log('Emitted value: ', event.data);\r\n     * });\r\n     * ...\r\n     * emitter.emit('some-event', 'payload')\r\n     *        .emit('another-event');\r\n     * ```\r\n     *\r\n     * @param {string} type\r\n     *      Type (name) of event for which to call handlers.\r\n     * @param {...any} [params]\r\n     *      Any values that should be available in handlers.\r\n     * @return {EventEmitter}\r\n     *      `this`.\r\n     */\r\n    emit(type, ...params) {\r\n        let eventData = this[dataField];\r\n        if (eventData && (eventData = eventData[type]) && eventData.length) {\r\n            const eventObj = {\r\n                type,\r\n                params,\r\n                data: params[0]\r\n            };\r\n            let i = 0;\r\n            let item;\r\n            // eslint-disable-next-line no-cond-assign\r\n            while (item = eventData[i++]) {\r\n                item.handler.call(item.obj, eventObj);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n};\r\n\r\n/**\r\n * Create event emitter or add methods to work with events into specified object.\r\n *\r\n * @param {Object} [target]\r\n *      Object that should be enhanced by methods to work with events.\r\n *      If `target` is not passed then new event emitter will be created and returned.\r\n * @return {EventEmitter}\r\n *      Value of `target` parameter or new object that is enhanced by methods to work with events.\r\n */\r\nexport default function getEmitter(target) {\r\n    return Object.assign(target || {}, api);\r\n}\r\n\r\nexport { getEmitter };\r\n"]}